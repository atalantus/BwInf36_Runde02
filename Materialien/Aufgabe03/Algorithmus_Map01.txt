/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		Algorithmus:
		1. Suche nach QuaxPos
		2. Dann Suche nach StadtPos
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Pathfinder 
{
	Vector2 QuaxPos;
	Vector2 StadtPos;
	Node Start;
	
	public bool FindPath() 
	{			
		return Start.SearchPath(QuaxPos, StadtPos, false);
	}
	
}

class Node 
{
	enum RechteckTypen 
	{
		PASSIERBAR, // Land und gemischt <= 20x20
		WASSER,
		GEMISCHT
	}
	RechteckTypen rechteckTyp;
	int Breite;
	
	public bool SearchPath(Vector2 startPos, Vector2 targetPos, bool hasStart) 
	{
		if (rechteckTyp == RechteckTypen.UNBEKANNT) rechteckTyp = GetRechteckTyp(Breite); // ist ein Flug der Drohne
		
		if (rechteckTyp == WASSER) return false;
		if (rechteckTyp == PASSIERBAR) return true;
		if (rechteckTyp == GEMISCHT) 
		{
			innereQuadrate = // Unterteile in innere Quadrate
			Quadrat[] sortedQuadrate = new Quadrat[4];
			
			if (!hasStart) 
			{
				sortedQuadrate = Innere Quadrate sortiert nach Nähe zu startPos (Erste ist das mit der geringsten Entfernung)
				
				for (int i = 0; i < sortedQuadrate.length; i++) 
				{
					Node aktuellesInneresQuadrat = sortedQuadrate[i]
					bool foundTarget = aktuellesInneresQuadrat.SearchPath(startPos, targetPos, hasStart);
					
					if (foundTarget) // Weg zum Start wurde gefunden
					{ 
						this.SearchPath(startPos, targetPos, true); // Starte Suche zu Ziel
					}
				}
				
				// Es wurde kein Weg zum Start gefunden!
				return false;
			}
		}
	}
	
	///
	/// REPRAESENTIERT EINEN DROHNEN FLUG !!!
	///
	private RechteckTypen GetRechteckTyp(int breite) 
	{
		// TODO: Markiere Gebiet auf Karte
		if (allesWasser) return RechteckTypen.WASSER;
		else if (allesLand || breite == 2) return RechteckTypen.PASSIERBAR;
		else return RechteckTypen.GEMISCHT;
	}
	
	/*
	public bool SearchQuax(Vector2 startPos) 
	{
		rechteckTyp = GetRechteckTyp(Breite);
		
		if (rechteckTyp == WASSER) return false;
		if (rechteckTyp == PASSIERBAR) return true;
		if (rechteckTyp == GEMISCHT) 
		{
			Unterteile in innere Quadrate
			bool möglicherWeg = false;
			Quadrat[] sortedQuadrate = new Quadrat[4];

			sortedQuadrate = Innere Quadrate sortiert nach Nähe zu startPos (Erste ist das nächste)
			
			for (int i = 0; i < sortedQuadrate.length; i++) 
			{
				Node aktuellesInneresQuadrat = sortedQuadrate[i]
				hatQuaxPos = nächstesQuadrat.SearchPath(Vector2 startPos, Vector2 targetPos, hatQuaxPos);
				
				if (hatQuaxPos) // Quax gefunden
					return true;
			}
			
			// Quax wurde nicht gefunden!
			return false;
		}
	}
	*/
}